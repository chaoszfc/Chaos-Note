## 4.3垃圾收集
#### javaScript具有自动垃圾收集机制。也就是说，执行环境会负责管理代码执行过程中使用的内存。而在C和C++之类的语言中，开发人员的一项基本任务就是手工跟踪内存的使用情况。这是造成许多问题的一个根源。在编写JavaScript程序时。开发人员不用关心内存使用问题。所需内存的分配以及无用内存的回收完全实现了自动管理。这种垃圾回收机制的原理其实很简单，找出那些不再继续使用的变量。然后释放其占用的内存。为此，垃圾收集器会按照固定的时间间隔（或代码执行中预定的收集时间）。周期性的执行这一操作。
#### 下面我们来分析一下函数中局部变量的正常生命周期。局部变量只在函数执行的过程中存在。而在这个过程中。会为局部变量在栈内存上分配相应的空间。以便存储他们的值。然后再函数中使用这些变量。直至函数执行结束。此时，局部变量就没有存在的必要了。因此，可以释放他们的内存以供将来使用。在这种情况下，很容易判断变量是否还有存在的必要，但并没所有情况下都这么容易就能得到结论。垃圾收集器必须跟踪哪个变量有用没用。对于不再有用的变量打上标记，以备将来收回其占用的内存。用于标识无用变量的策略可能会因实现而异。但具体到浏览器中的实现，则通常有两个策略。

----

### 4.3.1标记清除
#### JavaScript中最常用的垃圾收集方式是标记清除。当变量进入环境时。就将这个变量标记为“进入环境”。从逻辑上将。永远不能释放进入环境的 `变量` 所占用的 `内存` 。因为只要执行流进入相应的环境，就可以会用到他们.而当变量离开环境时。则将其标记为“离开环境”。
#### 可以使用任何方式来标记变量。比如。可以通过翻转某个特殊的位来记录一个变量何时进入环境，或者一个“进入环境的”变量列表及一个“离开环境的”变量列表来跟踪哪个变量发生了变化。说到底。如何标记变量其实并不重要。关键在于采取什么策略。垃圾收集器在运行的时候会给储存在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的变量的标记。而在此之后再被加上标记的变量将被视为准备删除的变量。原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成清除内存。销毁那些带标记的值并回收他们所占用的内存空间。
----
### 4.3.2引用计数
#### 另一种不太常见的垃圾收集策略叫做引用计数。引用计数的含义是跟踪记录每个值引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时。则这个值得引用次数就是1.相反。如果包含对这个值引用的变量又取得了另外一个值。则这个值得引用次数减1.当这个值得引用次数变为0时。这说明没有办法再范文这个值了。因为就可以把其占用的内存空间收回来。
#### 但是这就导致了一个问题
```
function problem (){
    var objA = new Object();
    var objB = new Object();

    objectA.someOtherObject = objectB;
    objectB.anontherObject = objectA;
}
```
#### 在这个栗子中，objA和objB通过各自的属性相互引用。也就是说。这两个对象的引用次数都是2.在采用标记清楚策略的实现中。由于函数执行之后。这两个对象都离开了作用域。因此这种相互作用不是个问题。但在采用引用计数策略的实现中。当函数执行完毕后。objA和objB还将继续存在。因为他们的引用次数永远不会是0，假如这个函数被重复多次调用。就会导致大量内存得不到回收。

#### COM对象导致的循环引用问题：
```
var element = document.getElementById("some_element");
var myObject = new Object();
myObject.element = element;
element.someObject = myObject;
```
#### 这个栗子在DOM元素与一个原生JavaScript对象之间创建了循环引用。其中，变量myObject有一个名为element的属性指向element对象。而变量element也有一个属性名叫someObject回指myObject。由于存在这个循环引用。即使将栗子中的DOM从页面中移除。它也永远不会被回收。

#### 为了避免该问题。最后是手动断开原生js对象与DOM元素的链接。例如。
```
myObject.element = null;
element.someObject = null;
```

----