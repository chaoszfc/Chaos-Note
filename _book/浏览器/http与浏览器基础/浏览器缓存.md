## 浏览器缓存
##### 2019年12月26日14:27:40
----
### 缓存是浏览器性能优化最关键的一环，同时，在开发中缓存问题也是不可避免的另开发人员头痛的问题。接下来分3个部分解释清楚浏览器缓存问题
- 强缓存
- 协商缓存
- 缓存位置
 
## 强缓存
#### 浏览器中的缓存作用分为两种情况，一种是需要发送HTTP请求，一种是不需要发送。
#### 首先是检查强缓存，这个阶段不需要发送HTTP请求。
#### 浏览器如何检查呢？
#### 在`HTTP/1.0`和`HTTP/1.1`当中，这个字段是不一样的。在早期，也就是`HTTP/1.0`时期，使用的是`Expires`，而`HTTP/1.1`使用的是`Cache-Control`。让我们首先来看看`Expires`。

_Expires_
>
>Expires即过期时间，存在于服务端返回的响应头中，告诉浏览器在这个过期>时间之前可以直接从缓存里面获取数据，无需再次请求。比如下面这样:
>```
>Expires: Wed, 25 Dec 2019 08:41:00 GMT
>
>```
>表示资源在2019年11月22号8点41分过期，过期了就得向服务端发请求。
>
>这个方式看上去没什么问题，合情合理，但其实潜藏了一个坑，那就是`服务器的时间和浏览器的时间可能并不一致`，那服务器返回的这个过期时间可能就是不准确的。因此这种方式很快在后来的HTTP1.1版本中被抛弃了。

----
_Cache-Control_

>在HTTP1.1中，采用了一个非常关键的字段：`Cache-Control`
>
>它和`Expires`本质的不同在于它并没有采用具体的过期时间点这个方式，而是采用`过期时长来控制缓存`，对应的字段是`max-age`。比如这个例子:
>```
> Cache-Control:max-age=3600
>```
>代表这个响应返回后在 3600 秒，也就是一个小时之内可以直接使用缓存。
>Cache-Control不单单只有max-age这个属性  

public: 客户端和代理服务器都可以缓存。因为一个请求可能要经过不同的代理服务器最后才到达目标服务器，那么结果就是不仅仅浏览器可以缓存数据，中间的任何代理节点都可以进行缓存。  

private： 这种情况就是只有浏览器能缓存了，中间的代理服务器不能缓存。  

no-cache: 跳过当前的强缓存，发送HTTP请求，即直接进入`协商缓存阶段`。  

no-store：非常粗暴，不进行任何形式的缓存。  

s-maxage：这和max-age长得比较像，但是区别在于s-maxage是针对代理服务器的缓存时间。  

### 当Expires和Cache-Control同时存在的时候，Cache-Control会优先考虑。
----
### 协商缓存
强缓存失效之后，浏览器在请求头中携带相应的`缓存tag`来向服务器发请求，由服务器根据这个tag，来决定是否使用缓存，这就是`协商缓存`。

这样的缓存tag分为两种: Last-Modified 和 ETag。这两者各有优劣，并不存在谁对谁有绝对的优势，跟上面强缓存的两个 tag 不一样。

### Last-Modified  

>即最后修改时间。在浏览器第一次给服务器发送请求后，服务器会在响应头中加上这个字段。浏览器接收到>>后，如果再次请求，会在请求头中携带If-Modified-Since字段，这个字段的值也就是服务器传来的最后修改时间。 
>
>服务器拿到请求头中的If-Modified-Since的字段后，其实会和这个服务器中该资源的最后修改时间对比:
>
>如果请求头中的这个值小于最后修改时间，说明是时候更新了。返回新的资源，跟常规的HTTP请求响应的流>程一样。否则返回304，告诉浏览器直接用缓存。

### ETag
>ETag 是服务器根据当前文件的内容，给文件生成的唯一标识，只要里面的内容有改动，这个值就会变。服务器通过响应头把这个值给浏览器。  
>
>浏览器接收到ETag的值，会在下次请求时，将这个值作为If-None-Match这个字段的内容，并放到请求头中，然后发给服务器。  
>
>服务器接收到If-None-Match后，会跟服务器上该资源的ETag进行比对:  
>
>如果两者不一样，说明要更新了。返回新的资源，跟常规的HTTP请求响应的流程一样。否则返回304，告诉浏览器直接用缓存。

### 两者对比

>在精准度上，ETag优于Last-Modified。优于 ETag 是按照内容给资源上标识，因此能准确感知资源的变化。而 Last-Modified 就不一样了，它在一些特殊的情况并不能准确感知资源变化，主要有两种情况:
>
>
>编辑了资源文件，但是文件内容并没有更改，这样也会造成缓存失效。
Last-Modified 能够感知的单位时间是秒，如果文件在 1 秒内改变了多次，那么这时候的 Last-Modified 并没有体现出修改了。
>
>
>在性能上，Last-Modified优于ETag，也很简单理解，Last-Modified仅仅只是记录一个时间点，而 Etag需要根据文件的具体内容生成哈希值。
>
>另外，如果两种方式都支持的话，服务器会优先考虑ETag。